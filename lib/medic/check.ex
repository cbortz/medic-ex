defmodule Medic.Check do
  @moduledoc "Reusable check functions"

  alias Medic.UI

  @doc false
  def run({module, meta_function}),
    do: run({module, meta_function, []})

  @doc false
  def run({module, function, args}) do
    UI.item(
      module |> Module.split() |> List.last(),
      function |> to_string() |> String.replace("_", " "),
      args
    )

    if skipped?(module, function, args) do
      :skipped
    else
      apply(module, function, args)
    end
  end

  @doc """
  Usable within a check. If the command exits with a 0 status code, then `:ok`, is returned.
  If the command returns a non-zero status code, then `{:error, output, remedy}` is returned,
  where output is any text generated by the command.
  """
  @spec command_succeeds?(binary(), list(binary()), remedy: binary()) :: :ok | {:error, binary(), binary()}
  def command_succeeds?(command, args, remedy: remedy) do
    case System.cmd(command, args) do
      {_output, 0} -> :ok
      {output, _} -> {:error, output, remedy}
    end
  end

  def in_list?(item, list, remedy: remedy),
    do: if(item in list, do: :ok, else: {:error, "“#{item}” not found in #{inspect(list)}", remedy})

  def skipped?(module, function, args),
    do:
      {module, function, args}
      |> skip_file()
      |> File.exists?()

  def skip_file({module, function}), do: skip_file({module, function, []})

  def skip_file({module, function, args}) do
    arg_list = args |> Enum.join("+")

    filename =
      [module, function, arg_list]
      |> Enum.filter(fn
        "" -> false
        _ -> true
      end)
      |> Enum.join("-")
      |> String.replace(~r{[^\w\-_\+\.]+}, "")

    Path.join(".medic/skipped", filename)
  end
end
